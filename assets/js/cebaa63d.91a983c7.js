"use strict";(self.webpackChunk_blockchain_lab_um_ssi_snap_docs=self.webpackChunk_blockchain_lab_um_ssi_snap_docs||[]).push([[822],{8841:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>c,frontMatter:()=>s,metadata:()=>o,toc:()=>p});var n=a(8427),r=(a(2784),a(876));const s={sidebar_position:2},i="Design",o={unversionedId:"ssi-snap/design",id:"ssi-snap/design",title:"Design",description:"SSI Snap is a MetaMask Snap that adds support for SSI: it can manage DIDs, store VCs, and create the VPs. It is designed to be blockchain-agnostic. SSI Snap works on existing MetaMask accounts (which are already DIDs of some methods) and their private keys to create new DIDs, without the need to create new private keys and worry about their security!",source:"@site/docs/ssi-snap/design.md",sourceDirName:"ssi-snap",slug:"/ssi-snap/design",permalink:"/ssi-snap-docs/docs/ssi-snap/design",draft:!1,editUrl:"https://github.com/blockchain-lab-um/ssi-snap-docs/edit/master/docs/ssi-snap/design.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"SSI Snap",permalink:"/ssi-snap-docs/docs/category/ssi-snap"},next:{title:"Architecture",permalink:"/ssi-snap-docs/docs/ssi-snap/architecture"}},l={},p=[{value:"DID Methods",id:"did-methods",level:2},{value:"Switching between different DID methods",id:"switching-between-different-did-methods",level:3},{value:"Verifiable Data",id:"verifiable-data",level:2},{value:"Verifiable Credentials (VCs)",id:"verifiable-credentials-vcs",level:3},{value:"Verifiable Presentations (VPs)",id:"verifiable-presentations-vps",level:3},{value:"Cryptography",id:"cryptography",level:2},{value:"Cryptographic keys",id:"cryptographic-keys",level:3},{value:"Proof formats",id:"proof-formats",level:3},{value:"Data Storage",id:"data-storage",level:2},{value:"Decentralized Identity Framework",id:"decentralized-identity-framework",level:2}],d={toc:p};function c(e){let{components:t,...a}=e;return(0,r.kt)("wrapper",(0,n.Z)({},d,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"design"},"Design"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"SSI Snap")," is a MetaMask Snap that adds support for ",(0,r.kt)("strong",{parentName:"p"},"SSI"),": it can manage ",(0,r.kt)("strong",{parentName:"p"},"DIDs"),", store ",(0,r.kt)("strong",{parentName:"p"},"VCs"),", and create the ",(0,r.kt)("strong",{parentName:"p"},"VPs"),". It is designed to be blockchain-agnostic. SSI Snap works on existing MetaMask accounts (which are already DIDs of some methods) and their private keys to create new DIDs, without the need to create new private keys and worry about their security!"),(0,r.kt)("h2",{id:"did-methods"},"DID Methods"),(0,r.kt)("p",null,"When working with SSI, choosing the DID method can take a lot of work. One of the most popular methods is called ",(0,r.kt)("strong",{parentName:"p"},"did:ethr"),". This method uses Ethereum addresses as fully self-managed DIDs. In other words, every Ethereum account is a DID. An example of an Ethereum address as a DID:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"did: ethr: 0x9907a0cf64ec9fbf6ed8fd4971090de88222a9ac;\n")),(0,r.kt)("p",null,"Ethereum accounts in MetaMask are already essentially DIDs. Only the needed functionality to use them and leverage their potential correctly was missing."),(0,r.kt)("p",null,"Now you might ask yourselves why we have decided to build a proof of concept on Ethereum in the first place. There were a couple of reasons:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Besides Bitcoin, it's the most decentralized blockchain."),(0,r.kt)("li",{parentName:"ul"},"It's the most popular and most commonly used blockchain for practical applications."),(0,r.kt)("li",{parentName:"ul"},"Huge developer community with many already established frameworks, including various SSI & DID frameworks and battle-tested ",(0,r.kt)("inlineCode",{parentName:"li"},"did:ethr")," method."),(0,r.kt)("li",{parentName:"ul"},"DID Documents don't have to be changed often (or even never in some cases); hence gas fees do not present such a huge problem.")),(0,r.kt)("p",null,"But a single DID method cannot fit all the different use cases and projects. Thus we are developing SSI Snap in a way that the user can change the DID method that she is currently using (similar to selecting a network in MetaMask), or dApp/app can enforce the usage of a specific DID method if its functionalities depend on it."),(0,r.kt)("h3",{id:"switching-between-different-did-methods"},"Switching between different DID methods"),(0,r.kt)("p",null,"In SSI Snap, users can pick a different DID method for every MetaMask account. For example, if they want to use ",(0,r.kt)("inlineCode",{parentName:"p"},"did:ethr")," on Account 1 and ",(0,r.kt)("inlineCode",{parentName:"p"},"did:key")," on Account 2, they can!"),(0,r.kt)("p",null,"For the complete list of supported DID methods, check ",(0,r.kt)("a",{parentName:"p",href:"./supported"},"this page"),"."),(0,r.kt)("h2",{id:"verifiable-data"},"Verifiable Data"),(0,r.kt)("p",null,"There are two types of Verifiable Data in the SSI trust model and lifecycle digitally signed by different; thus, we deal with them slightly differently."),(0,r.kt)("h3",{id:"verifiable-credentials-vcs"},"Verifiable Credentials (VCs)"),(0,r.kt)("p",null,"SSI Snap supports storing VCs in its local storage or on different supported networks. It also enables storing some data locally, such as personal passports and driving licenses, while other less critical data, like conference certificates or course applications, on the public networks. Best of all, users can decide where their data should end up!"),(0,r.kt)("p",null,"For more information on the storage, check ",(0,r.kt)("a",{parentName:"p",href:"./storage"},"this page"),"."),(0,r.kt)("h3",{id:"verifiable-presentations-vps"},"Verifiable Presentations (VPs)"),(0,r.kt)("p",null,"On the other hand, VPs are signed by holders using their wallets (which is SSI Snap). Usually, they are signed on the go when requested by different applications. SSI Snap supports creating VP from single or multiple VCs."),(0,r.kt)("h2",{id:"cryptography"},"Cryptography"),(0,r.kt)("p",null,"Cryptography is what makes everything secure and possible. VCs and VPs are both digitally signed and verifiable by everyone that gets in contact with them. Because of developing on web3/Ethereum wallet, we are reusing your existing cryptography keys, so the users do not have to worry about backing up the additional keys."),(0,r.kt)("h3",{id:"cryptographic-keys"},"Cryptographic keys"),(0,r.kt)("p",null,"Ethereum relies on the elliptic curve ",(0,r.kt)("inlineCode",{parentName:"p"},"secp256k1"),"; thus, this is the only key type available in the MetaMask. Using the derivation schemes presented in the different ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/bitcoin/bips"},"BIP standards"),", it is possible to generate multiple key pairs (and associated accounts) from a single seed phrase. Backing up the seed phrase automatically backup all keys since they can always be derived deterministically, which solves the problem of other SSI wallets that generate new keys each time from scratch and not in relation to the previous keys."),(0,r.kt)("p",null,"But because of the limitation of the specific key type, we currently can only support all DID methods that work on ",(0,r.kt)("inlineCode",{parentName:"p"},"secp256k1")," keys. There is a way to create key pair of any type (e.g., Ed25519) in the Snap (since you can write any custom JavaScript), but storing and securely handling these keys gets complicated. But because the elliptic curve ",(0,r.kt)("inlineCode",{parentName:"p"},"secp256k1")," is widely used, most DID methods support it."),(0,r.kt)("p",null,"We are also looking into pairing-friendly elliptic curves, which enable advanced ways to perform selective disclosure and zero-knowledge proofs, e.g., ",(0,r.kt)("inlineCode",{parentName:"p"},"BLS12-381"),", where it would make sense to implement custom and complex security storage for keys generated inside Snap."),(0,r.kt)("h3",{id:"proof-formats"},"Proof formats"),(0,r.kt)("p",null,"There are different ways to digitally sign and represent digital signatures alongside the data or payload (VC or VP). In the SSI and web3 world, currently, three approaches are most adopted: ",(0,r.kt)("strong",{parentName:"p"},"JWT"),", ",(0,r.kt)("strong",{parentName:"p"},"Linked Data Proofs"),", and ",(0,r.kt)("strong",{parentName:"p"},"EIP712"),". SSI Snap supports all three types."),(0,r.kt)("p",null,"For the complete list of supported proof formats, check ",(0,r.kt)("a",{parentName:"p",href:"./supported"},"this page"),"."),(0,r.kt)("h2",{id:"data-storage"},"Data Storage"),(0,r.kt)("p",null,"As stated above, DIDs and VCs need to be stored somewhere. We plan to support many different data storage providers to fulfill all users' needs. While keeping data locally in the MetaMask state is the most private way to store the data (it is also encrypted), other solutions bring many benefits, such as the ability to sync between different devices and easier ways to make external backups."),(0,r.kt)("p",null,"For the complete list of supported data storage providers, check ",(0,r.kt)("a",{parentName:"p",href:"./supported"},"this page"),"."),(0,r.kt)("h2",{id:"decentralized-identity-framework"},"Decentralized Identity Framework"),(0,r.kt)("p",null,"Using a framework is the best way to handle DIDs and VCs in the code. SSI Snap uses ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("a",{parentName:"strong",href:"https://veramo.io/"},"Veramo"))," for that purpose. Veramo is a performant and modular API for Verifiable Data and Decentralized Identity/SSI. It's a library that allows the creation and management of DIDs, VCs, and VPs and makes developers' lives working with them much easier. We highly encourage you to check their website!"))}c.isMDXComponent=!0},876:(e,t,a)=>{a.d(t,{Zo:()=>d,kt:()=>u});var n=a(2784);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function s(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?s(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):s(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},s=Object.keys(e);for(n=0;n<s.length;n++)a=s[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(n=0;n<s.length;n++)a=s[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var l=n.createContext({}),p=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},d=function(e){var t=p(e.components);return n.createElement(l.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},h=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,s=e.originalType,l=e.parentName,d=o(e,["components","mdxType","originalType","parentName"]),h=p(a),u=r,m=h["".concat(l,".").concat(u)]||h[u]||c[u]||s;return a?n.createElement(m,i(i({ref:t},d),{},{components:a})):n.createElement(m,i({ref:t},d))}));function u(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var s=a.length,i=new Array(s);i[0]=h;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o.mdxType="string"==typeof e?e:r,i[1]=o;for(var p=2;p<s;p++)i[p]=a[p];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}h.displayName="MDXCreateElement"}}]);